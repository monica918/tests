## 虚拟机和容器化

|项目 | 虚拟机 | 容器 |
| ------ | ------ | ------ |
| 启动时间 | 分钟级启动,由于虚拟机需要启动和运行完整的操作系统，所以启动时间相对较长，需要分配较多的资源| 秒级启动,基于现有的宿主机操作系统运行的，启动时间通常较短，并且占用的资源相对较少，可以在同一宿主机上同时运行多个容器|
| 体积 | 以G为单位 | 容器镜像大小通常以M为单位 |
|性能| 需要虚拟化硬件设备，具有完整的Guest OS,开销大，性能较容器差|因为共享了宿主机内核，只是进程级的隔离，因此隔离性和稳定性不如虚拟机。且容器有权限访问宿主机内核，存在一定的安全隐患|
| 共享资源 | 通过虚拟化底层硬件资源（如CPU、内存、存储等），创建多个完整的操作系统实例，每个虚拟机都有自己的操作系统内核和运行时环境 |利用操作系统级别的虚拟化技术，Docker 使用主机的资源来运行容器，每个容器都是一个独立的进程，相互之间隔离。容器共享主机的操作系统内核，但具有自己的文件系统、进程空间和网络。每个容器在运行时消耗一定的 CPU 和内存资源。|
| 操作系统 | 每个虚拟机实例可以运行不同的操作系统 |每个容器共享宿主机的操作系统内核，因此每个容器中运行的应用程序都必须与宿主机使用相同的操作系统 |



## 操作系统包括以下主要组件：

内核（Kernel）：内核是操作系统的核心部分，负责管理计算机的硬件资源，包括内存管理、进程管理、文件系统管理、设备驱动程序等。

文件系统（File System）：文件系统用于组织和管理计算机上的文件和目录。它提供了对文件的创建、读取、写入和删除等操作。

进程管理（Process Management）：进程管理负责管理计算机中运行的进程。它包括进程的创建、调度、同步和通信等操作。

内存管理（Memory Management）：内存管理负责分配和管理计算机的内存资源，包括内存分配、内存回收和虚拟内存等操作。

设备管理（Device Management）：设备管理负责管理计算机中的设备，包括硬件设备和外部设备。它涉及设备的初始化、驱动程序的加载和设备的操作等。

用户界面（User Interface）：用户界面提供了用户与操作系统之间的交互方式，包括命令行界面和图形用户界面等。

网络管理（Network Management）：网络管理负责管理计算机系统中的网络连接和通信。它包括网络配置、网络协议的支持和网络资源的管理等。


## 镜像与容器
定义：镜像是一个静态的、可执行的软件包，它包含了运行一个应用程序所需的所有依赖项和配置。容器是从镜像创建的运行实例，它可以独立运行并具有自己的文件系统、进程空间和网络环境。

创建和部署：镜像是创建容器的基础，它是容器的模板。通过使用Docker的命令，可以从镜像创建并启动一个或多个容器。

可移植性：镜像具有可移植性，可以在不同的环境中部署和运行，保持一致的运行方式。容器则是镜像的实例化，可以在不同的主机上运行。

可变性：镜像是不可变的，一旦创建就不能被修改。容器是可变的，可以通过修改容器的状态、配置和数据来适应不同的需求。

存储：镜像被存储在镜像仓库中，可以通过网络下载到本地。容器的状态和数据是存储在宿主机上的，容器可以读取和写入宿主机上的文件系统。

关系：一个镜像可以用来创建多个容器，多个容器可以共享同一个镜像。容器之间相互隔离，互不影响。

举例：假设你有一个做蛋糕的配方，这个配方就相当于Docker镜像。它包含了制作蛋糕所需的所有步骤、材料和工具，是一个静态的、可执行的指导书。当你想要做一个蛋糕时，你可以使用这个配方创建一个实际的蛋糕，这个蛋糕就相当于Docker容器。它是从配方（镜像）创建的一个具体的实例，拥有自己的形状、味道和装饰。
你可以根据需要创建多个相同的蛋糕，每个蛋糕都独立存在，并且可以按照相同的方式重复制作。

镜像是一种模板或者规范，它定义了容器所需的所有组件和配置。它可以被用来创建多个相同的容器，每个容器都是基于相同的镜像构建的，但是它们之间是独立的、隔离的实例。

类比到生活中，镜像就像是一个食谱，而容器就像是你用这个食谱制作的蛋糕。你可以根据需要创建多个蛋糕，每个蛋糕都是基于同一个食谱制作的，但是它们是独立的实体。这样，你可以方便地重复制作相同的蛋糕，而不必重新编写制作步骤和配料清单。同时，你可以根据需要调整每个蛋糕的装饰和口味，每个蛋糕都是相互隔离的。

通过使用Docker，我们可以创建、共享和部署镜像，从而实现应用程序的快速部署和可移植性。同时，每个容器都是基于镜像创建的独立运行实例，具有自己的文件系统、进程空间和网络环境，实现了应用程序的隔离和轻量化部署。


## 传统部署与容器化部署
传统部署方式中，需要手动安装和配置应用程序的运行环境，包括操作系统、依赖库、配置文件等。这个过程通常比较繁琐，需要花费较多的时间和精力。

而通过容器化，可以将应用程序及其所有依赖项打包成一个独立的容器镜像，包括运行环境、依赖库和配置文件等。这样，在部署时只需要运行容器镜像，就能够快速地启动应用程序，而无需手动安装和配置。

容器镜像中已经包含了应用程序所需的一切，因此可以在不同的环境中轻松部署和迁移。而且，容器化还能够提供一致性的部署，确保在不同的环境中应用程序的运行行为一致。

因此，容器化可以显著简化应用程序的部署过程，减少配置错误和依赖问题，提高部署的可靠性和可重复性。同时，还可以节省时间和资源，使应用程序更加灵活和可移植。


## 映射/挂载
- "Volume挂载"是指将宿主机上的目录或文件系统挂载到容器中，使得容器可以访问并操作宿主机上的数据。通过Volume挂载，容器可以持久化存储数据，而不会受到容器的生命周期影响。
具体来说，Volume挂载将宿主机上的目录与容器中的目录进行映射，进行关联，使得两者之间的数据可以进行双向的读写操作。这意味着容器内部的应用程序可以读取和写入宿主机上挂载的目录中的文件，同时宿主机也可以访问和修改容器内部的数据。
通过Volume挂载，容器可以持久保存数据，即使容器被删除或重启，数据仍然保留在宿主机上的挂载目录中。这对于需要长期存储和共享数据的应用场景非常有用，例如数据库文件、日志文件、配置文件等。
总而言之，Volume挂载是一种将宿主机上的目录或文件系统与容器中的目录进行关联的机制，使得容器可以持久化存储数据并与宿主机进行数据交互。它提供了数据的持久性和共享性，为容器化应用带来更大的灵活性和可靠性。


## 主机能够运行多少个容器，需要考虑以下因素：
- CPU：主机的 CPU 核心数量和性能限制了容器的并发执行能力。较多的 CPU 核心可支持更多的容器。
- 内存：主机的可用内存限制了容器的内存分配。每个容器都需要一定的内存资源来运行。
- 网络带宽：如果容器之间需要进行网络通信，主机的网络带宽可能成为限制因素。
- 磁盘空间：每个容器需要一定的磁盘空间来存储容器的文件系统和数据。

## 容器运行参数
|参数   |     描述|
|------|------|
|--name	|给容器命名|
|-d	|运行容器到后台|
|--restart	|容器退出后的重启策略，默认no[always|failure]|
|-v	|挂载宿主机目录到容器|
|--network	|连接容器到一个网络|
|-e	|设置环境变量|
|-i	|交互式创建容器|
|-t	|分配一个伪终端|
|-p	|映射容器端口到主机|
|-h	|设置容器主机名|
|--link	|添加连接到另一个容器|



## 复制环境
- 本地的dockerfile/compose/项目代码上传到远程  
 a环境拉取 运行命令  
 b环境拉取 运行命令












