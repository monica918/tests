## Kafka定义
- Kafka 是一个分布式的基于发布-订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。

## 注意点
- 应用于分布式，因为是服务与服务之间的通信



消息队列是为了解决消息间通信繁忙而诞生的，体现了解耦和异步的实现
为了解决消息间通信繁忙的问题，我们可以理解为引入了一个中间件(消息队列),发送方在发送信息的时候，不是直接发送到接收方，而是发送信息到中间件，接收方通过中间件获取自己想要的信息。
在这个过程中，我们可以把发送方理解为生产者，接收方认为是消费者。
生产者发布信息,消费者订阅信息(通过中间件)
引出一个问题，消费者如何拿到自己想要的数据，这个问题的解决方法就是主题(topic)，生产者将不同主题的信息发布到中间件(kafka)中，消费者通过订阅不同的主题来消费自己想要的数据
在主题下面会有分区，分区可以实现分布在不同的服务器上，生产者将数据存储在主题下的不同分区里面
两种模式：1.生产者指定分区 2.分区器（一个算法）通过消息的键（一个标记）来安排数据的存储空间

我们现在可以知道一条消息可能带有以下几个数据：1.主题 2.分区 3.键 4.值(想传送的数据)

那消费者如何读取数据呢？引出偏移量
偏移量（offset）：第几个
一个分区里面，每个消息的偏移量都是唯一的
消费者只能顺序读取

这样的话我们就实现了一个borker，borker里面包含主题，分区、
borker为传来的消息根据分区设置偏移量，将其存储在磁盘上，borker也为消费者提供服务，提供响应。
多个Borker集群就是kafka集群，这样就提供了消息的安全性。在这个集群中可能还会有一个集群负责控制器的角色。


在充电App中，Kafka可能与桩的状态变更和充电操作有关。以下是一个可能的使用情景：

用户选桩： 用户在App中选择一个空闲的充电桩进行充电。

生成充电事件： 当用户确认充电操作时，App生成一个充电事件，包含有关充电的信息，例如充电桩ID、用户ID、充电开始时间等。

事件发布到Kafka： 生成的充电事件可能会被发布到一个特定的Kafka主题。这样做的目的是将充电事件传递给系统中其他可能对此感兴趣的服务。

充电桩状态变更： 在App中，充电桩的状态可以通过订阅与充电相关的Kafka主题来实现。一旦充电事件被发送到Kafka，充电桩服务（可能是后台服务）可以订阅该主题，接收充电事件，然后更新相应充电桩的状态为"充电中"。

异步更新页面： 在前端，充电桩的状态可以采用乐观更新的方式，即在用户发起充电请求后，立即更新页面上的充电桩状态为"充电中"，而不必等待后台服务完成实际的充电桩状态变更。








前端页面更新： 在购买页面发送购买事件到 Kafka 之后，前端页面可以通过前端 JavaScript 或其他客户端逻辑直接更新显示。这是一个乐观更新的策略，前端假设购买请求成功并立即更新页面上的库存显示，而不必等待后端的实际库存变更。这一更新是通过前端本地的数据模型或直接操作 DOM 元素完成的，而不需要等待后端的实际库存操作。

javascript
Copy code
// 伪代码示例
function updateStockDisplay(newStock) {
    document.getElementById('stock-count').innerText = newStock;
}

// 在发送购买请求后，更新库存显示
updateStockDisplay(currentStock - purchaseQuantity);
后端库存服务处理： 同时，购买事件被发送到 Kafka 后，后端的库存服务从 Kafka 中消费这个购买事件，执行实际的库存减少操作。这一步是在后端进行的，与前端的库存显示更新是异步的，即前端不必等待后端完成库存操作。

后端通知前端（可选）： 如果后端处理购买事件后生成了新的事件，例如“库存变更”事件，并且系统使用了实时通信机制，后端可以向前端推送通知。这时，前端可以接收到通知并相应地更新库存显示。

所以，前端页面的变化是由前端本地逻辑驱动的，不直接依赖于后端的库存变更操作。后端的库存服务和后续的通知机制是为了确保系统的一致性和及时性，但并不是直接驱动前端页面的更新。前端通过本地逻辑实现了库存的即时变化，而后端是在异步的情况下执行实际的库存减少操作。


